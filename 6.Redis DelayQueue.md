# Redis延时队列
我们平时习惯于使用 Rabbitmq 和 Kafka 作为消息队列中间件，来给应用程序之间增加异步消息传递功能。

使用过 Rabbitmq 的同学知道它使用起来有多复杂，发消息之前要创建 Exchange，再创建 Queue，还要将 Queue 和 Exchange 通过某种规则绑定起来，发消息的时候要指定 routing-key，还要控制头部信息。消费者在消费消息之前也要进行上面一系列的繁琐过程。但是绝大
多数情况下，虽然我们的消息队列只有一组消费者，但还是需要经历上面这些繁琐的过程。

有了 Redis，它就可以让我们解脱出来，对于那些`只有一组消费者的消息队列`，使用Redis就可以非常轻松的搞定。

Redis的消息队列不是专业的消息队列，它没有非常多的高级特性，`没有ack保证`，如果对消息的可靠性有着极致的追求，那么它就不适合使用。

ACK: 在实际使用RocketMQ的时候我们并不能保证每次发送的消息都刚好能被消费者一次性正常消费成功，可能会存在需要多次消费才能成功或者一直消费失败的情况，那作为发送者该做如何处理呢？
RocketMQ提供了ack机制，以保证消息能够被正常消费。发送者为了保证消息肯定消费成功，`只有使用方明确表示消费成功，RocketMQ才会认为消息消费成功`。`中途断电，抛出异常等都不会认为成功——即都会重新投递`。

## Redis List
### lpush,rpush,linsert
redis中list列表的数据插入命令：lpush，rpush，linsert
```
127.0.0.1:6379> rpush testlist 1
(integer) 1    ---结果为：(integer) 1
127.0.0.1:6379> rpush testlist 2
(integer) 2    ---结果为：(integer) 2
127.0.0.1:6379> rpush testlist 3
(integer) 3    ---rpush命令：向mylist列表中,从右边插入3条数据，返回值为当前列表的容量。结果为：(integer) 3
127.0.0.1:6379> lrange testlist 0 -1
1) "1"
2) "2"
3) "3"         ---lrange命令：查看mylist列表中的数据，0开始位置，-1结束位置，结束位置为-1时，表示列表的最后一个位置，即查看所有。结果为：1> "1"  2> "2"  3> "3"
127.0.0.1:6379> lpush testlist 0
(integer) 4     ---lpush命令：向mylist列表中，从左边插入一条数据为0的数据
127.0.0.1:6379> lrange testlist 0 -1
1) "0"
2) "1"
3) "2"
4) "3"          ---结果为：1>"0"  2>"1"  3>"2"  4>"3"
127.0.0.1:6379> linsert testlist after 3 4
(integer) 5     ---linsert命令，表达式为linsert key before|after pivot value ;这句命令的意思是在key为mylist的列表中查找值为3的数据，在其后插入一条值为4的数据。
127.0.0.1:6379> lrange testlist 0 -1
1) "0"
2) "1"
3) "2"
4) "3"
5) "4"          ---结果为：1>"0"  2>"1"  3>"2"  4>"3"  5>"4"
127.0.0.1:6379> linsert testlist before 0 -1
(integer) 6     ---意思是：在key为mylist的列表中查找值为0的数据，在其前插入一条值为-1的数据。
127.0.0.1:6379> lrange testlist 0 -1
1) "-1"
2) "0"
3) "1"
4) "2"
5) "3"
6) "4"          ---结果为：1>"-1"  2>"0"  3>"1"  4>"2"  5>"3"  6>"4"
127.0.0.1:6379> linsert testlist after 5 8
(integer) -1    ---结果为：-1，由于mylist列表不存在值为5的数据，所以不执行任何操作，返回状态值-1。如果key不存在时，返回错误提示。
127.0.0.1:6379> lrange testlist 0 -1
1) "-1"
2) "0"
3) "1"
4) "2"
5) "3"
6) "4"          ---结果为：1>"-1"  2>"0"  3>"1"  4>"2"  5>"3"  6>"4"
```

### lpop, rpop, ltrim
redis中list列表的数据删除命令：lpop，rpop
```
127.0.0.1:6379> lpop testlist
"-1"    ---lpop命令：从列表中的左边移除一条数据，同时输出被删除的数据，这里输出的结果为-1
127.0.0.1:6379> lrange testlist 0 -1
1) "0"
2) "1"
3) "2"
4) "3"
5) "4"  ---结果为：1>"0"  2>"1"  3>"2"  4>"3"  5>"4"
127.0.0.1:6379> rpop testlist
"4" ---rpop命令：从列表的右边移除一条数据，同时输出被删除的数据，这里输出的结果为4
127.0.0.1:6379> lrange testlist 0 -1
1) "0"
2) "1"
3) "2"
4) "3"
127.0.0.1:6379> ltrim testlist 1 3
OK      ----ltrim命令：保留设定的两个下标区间的值，删除不在其区间的所有值。1为开始保留的下标值，3为结束保留的下标值。
127.0.0.1:6379> lrange testlist 0 -1
1) "1"
2) "2"
3) "3"
```

###lrange, llen, lindex
redis中list列表的数据查看命令：lrange，llen，lindex
```
127.0.0.1:6379> llen testlist  
(integer) 3     ---llen命令：返回列表的长度
127.0.0.1:6379> lindex testlist 2
"3"         ---lindex命令：获取给定位置的数据
```

### lset
redis中list列表数据修改命令：lset
```
127.0.0.1:6379> lset testlist 2 aaa
OK      ---lset命令：把下标为2的值设置为aaa
127.0.0.1:6379> lrange testlist 0 -1
1) "1"
2) "2"
3) "aaa"
```

### blpop, brpop
```
127.0.0.1:6379>blpop A 30   ---意思是：A列表有值的话，从左边移除一个数据，如果没有值的话，则等待A中插入数据为止，等待时间为30秒，如果时间设置为0表示阻塞时间无限延长

127.0.0.1:6379>blpop B30   ---意思是：A列表有值的话，从左边移除一个数据，如果没有值的话，则等待A中插入数据为止，等待时间为30秒，如果时间设置为0表示阻塞时间无限延长
```

## Redis异步消息队列
Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用rpush/lpush操作入队列，使用 lpop 和 rpop 来出队列。

队列空了怎么办？ 客户端是通过队列的 pop 操作来获取消息，然后进行处理。处理完了再接着获取消息，再进行处理。如此循环往复，这便是作为队列消费者的客户端的生命周期。可是如果队列空了，客户端就会陷入 pop 的死循环，不停地 pop，没有数据，接着再 pop，又没有数据。这就是浪费生命的空轮询。
空轮询不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高，如果这样空轮询的客户端有几十来个，Redis 的慢查询可能会显著增多。通常我们使用`sleep`来解决这个问题，让线程睡一会，睡个 1s 钟就可以了。不但`客户端的 CPU `能降下来，Redis 的`QPS`也降下来了。

## 队列延迟
用上面睡眠的办法可以解决问题。但是有个小问题，那就是睡眠会导致消息的延迟增大。

有没有什么办法能显著降低延迟呢? 那就是`blpop/brpop`。这两个指令的前缀字符b代表的是 blocking，也就是阻塞读。

阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用 blpop/brpop 替代前面的 lpop/rpop，就完美解决了上面的问题。

## 空闲连接自动断开
上述方案会带来空闲连接的问题。

如果线程一直阻塞在哪里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候 blpop/brpop 会抛出异常来。所以编写客户端消费者的时候要小心，注意捕获异常，还要重试。！！！

## 锁冲突处理
上节课我们讲了分布式锁的问题，但是没有提到客户端在处理请求时加锁没加成功怎么办。一般有 3 种策略来处理加锁失败:
- 直接抛出异常，通知用户稍后重试;
- sleep 一会再重试;
- 将请求转移至延时队列，过一会再试;这种方式比较适合异步消息处理，将当前冲突的请求扔到另一个队列延后处理以避开冲突。

## 延时队列的实现
延时队列可以通过 Redis 的 zset(有序列表) 来实现。

我们将消息序列化成一个字符串作为 zset 的value，这个消息的`到期处理时间`作为score，然后用多个线程轮询 zset 获取到期的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。

Redis 的 zrem 方法是多线程多进程争抢任务的关键，它的返回值决定了当前实例有没有抢到任务， 因为 loop 方法可能会被多个线程、多个进程调用，同一个任务可能会被多个进程线程抢到，通过 zrem 来决定唯一的属主。

同时，我们要注意一定要对 handle_msg 进行异常捕获，避免因为个别任务处理问题导致循环异常退出。

## 进一步优化
上面的算法中同一个任务可能会被多个进程取到之后再使用zrem进行争抢，那些没抢到的进程都是白取了一次任务，这是浪费！！

可以考虑使用`lua scripting`来优化一下这个逻辑，将zrangebyscore和zrem一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费了。

## Redis作为消息队列为什么不能保证100%的可靠性
消息不保证可靠，应该是消息被发送出去，消费者是否接收到消息redis不做保证，不像一般的mq，会有ack机制，要求消费者收到消息进行ack确认，超时未确认mq会再次投递消息，而redis没有这个机制。为什么redis不考虑加上这个特性呢？我觉得还是其主要用途来决定的，毕竟不是专业消息中间件，同时消费者要做好幂等处理。


